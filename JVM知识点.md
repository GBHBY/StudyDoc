# JVM

## 类加载机制

### 类加载生命周期

![image-20220713150903067](image\image-20220713150903067.png)

- 加载验证准备初始化和卸载这五个阶段的顺序是确定的，类加载的顺序必须是按照这个顺序开始，**但是这些阶段都会交叉的进行**。
- 解析阶段开始的顺序是不一定的：某些情况下可以在初始化之后才开始。
- 至于什么时候开始加载，JVM规范中没有强制约束。但是初始化的阶段，则是由**六种**情况必须开始，除这六种情况之外，**所有引用类型的方式都不会触发初始化**，也就是被动引用。被动引用参考《JVM》P360.
  1. 遇到new,getstatic,putstatic,invokestatic
  2. 进行反射调用时
  3. 初始化类的时候发现父类没有初始化，需要先初始化父类
  4. 当虚拟机启动的时候，虚拟机会先初始化包含main方法的类
  5. 当一个接口种定义了jdk8新加入的默认方法，也就是default方法，如果有这个接口的实现类发生了初始化，则要优先初始化这个接口
  6. 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解 析结果为REF_getStatic、REF_p utStatic、REF_invokeStatic、REF_newInvokeSp ecial四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
- **而对于接口，接口在初始化的时候，不需要优先初始化父类，只有真正用到父接口的时候，才进行初始化**

### 类加载过程

#### 加载

- 在加载阶段，要完成一下三件事
  1. 通过一个类的全限定名来获取定义此类的二进制字节流
  2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  3. 在内存中生成一个代表这个类的class对象，作为方法区这个类的各种数据的访问入口

#### 验证

1. 文件格式验证
2. 元数据验证
   - 这是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求
   - 比如
     - 是否有父类
     - 父类是否继承了不被允许继承的类
     - 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
     - 等等
3. 字节码验证
4. 符号引用验证

#### 准备

- 准备节点是正式为类中定义的变量分配内存并设置类变量初始值的阶段，这个时候分配的仅是类变量，而不包括实例变量

  ````java
  
      //实例变量
      String id;
      //实例变量
      private String colorType;
      //实例变量
      private int size;
      //类变量(静态变量)
      private static int depart = 1;
  	private static final int value = 100;
  ````

- 不过对于类变量`depart`来讲，这个阶段它的值是0，而不是1。**但是对于`value`来讲，它的初始值是100**，这是因为：**如果类变量存在final，那么在准备阶段变量值就会初始化该变量所指定的初始值。**

#### 解析

- 解析阶段是JVM将常量池内的符号引用替换为直接引用的过程。
- 详情见P371

#### 初始化

- 初始化时类加载过程的最后一个阶段，直到初始化阶段，JVM才开始真正执行类中编写的Java程序代码。
- 详情见P376

### 类加载器

- 对于任意一个类，都必须有它的加载器和这个类本身一起确定其在Java中的唯一性。也就是说：**比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。**否则，即使两个类来自同一个class文件，但是由不同的类加载器加载，那么还是不同的类。

#### 双亲委派模型

- 启动类加载器（Bootstrap Class Loader）
  - 这个加载器负责加载存放在<JAVA_HOME>\lib目录下，或者被-Xbootclasspath参数所指定的路径中存放的类，而且是能够被JVM识别的（JVM是按照文件名识别的，否则即使是不符合的类库放到lib下也不会被加载），并且这个加载器是c++代码实现的。

- 扩展类加载器（Extension Class Loader）
  - 这个类加载器是以Java代码实现的，负责加载<JAVA_HOME>\lib\ext目录中的Java代码。
- 应用程序类加载器（Application Class Loader）
  - 以Java实现，用来加载用户类路径也就是ClassPath上的类库，开发者可以在代码中直接使用这个类加载器。如果开发者自己没有定义类加载器，一般这个就是默认的类加载器

<img src="image\image-20220714180948324.png" alt="image-20220714180948324" style="zoom: 50%;" />

- 上图中所展示的就是**双亲委派模型**，双亲委派模型的工作过程是：**如果一个类加载器收到了类加载的请求，首先它不会自己去加载，而是委派给父加载器去加载，每一个层次的类加载器都是如此，直到加载请求到了启动类加载器，只有当父加载器无法加载，就会让子加载器去加载**

- 使用双亲委派模型来组织类加载器之间的关系，**一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在tr.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。**反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。如果读者有兴趣的话，可以尝试去写一个与rt.jar类库中已有类重名的Java类，将会发现它可以正常编译，但永远无法被加载运行,**即使自定义了自己的类加载器，强行用defineClass()方法去加载一个以“java.lang”开头的类也不会成功。如果读者尝试这样做的话，将会收到一个由JVM内部抛出的“java.lang..SecurityException:Prohibitedpackagename:java.lang”异常。**

- [如果自己写了一个Object会怎么样](如果自己写了一个Object会怎么样)

  

