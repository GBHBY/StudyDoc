# JVM

## Java内存分布

### 运行时数据区域

- Java运行时数据区域可以按照**线程共享**分为

  - 线程共享的数据区

    - **堆**
      - 该区域是在JVM启动时创建，并只存放**对象实例**
      - 堆既可以实现成固定大小的，也可以是动态扩展的，主流的JVM都是可以动态扩展的（通过-Xmx和-Xms设定）。如果一个实例在堆中没有完成实力分配，并且堆也无法再扩展时，JVM会抛出OutOfMemeryError异常。
    - **方法区**
      - 存储已被JVM加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据
      - 该区域的内存回收主要目标是**针对常量池的回收和对类型的卸载**
      - 如果该区域无法满足新的内存分配的时候，会抛出OutOfMemeryError异常。
      - **运行时常量池**
        - 运行时常量池时方法区的一部分，当无法再申请到新的内存，也会内存溢出。

  - 线程隔离的数据区

    - **Java虚拟机栈**
      - 每个方法执行的时候，JVM都会建立一个**栈帧**，用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息。每一个方法调用直至执行完毕的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。
      - 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用
      - **JVM规范中规定：如果线程请求的栈深度大于JVM所允许的深度，就会抛出StackOverflow异常。如果JVM栈容量可以动态扩展（HotSpot不支持），当栈扩展到无法申请足够的内存时，就会抛出内存溢出异常**

    - **本地方法栈**
      - 与虚拟机栈一样，都会抛出StackOverflow异常和OutOfMemeryError异常
    - **程序计数器**
      - 每个线程都会有一个程序计数器，由于Java的多线程是轮询机制，所以每当线程切换的时候，需要一个程序计数器来记录当前线程已经执行到哪一步，并且该区域不会**内存溢出**，如果是**本地方法，这个计数器的值是零**

### 对象的创建过程

- 当JVM遇到一个new字节码命令的时候，首先会去检查这个指令的参数是否能在常量池定位一个类的符号引用，并且检查这个类是否已经加载、解析和初始化过。如果没有，那么先执行响应的类加载过程。
- 类加载后，先为对象进行内存分配。对象所需的内存在类加载的时候就可以确定。分配内存空间有两种方式
  1. 指针碰撞
     - 如果垃圾回收器带有**空间压缩整理**的能力，那么就采用指针碰撞。因为这样的堆内存比较规整，例如：Serial、ParNew
  2. 空闲列表
     - 如果垃圾回收器不带有空间压缩的能力，那么就采用空闲列表的方式去分配，例如：CMS
- 内存分配完成后，要把分配到的内存空间初始化为零。
- 如果init指令还没有执行，也就是构造方法还没有执行，所有的字段都默认为零，执行完init指令，一个真正可用的对象才创造出来。

### 对象的内存布局

- 在HotSpot中，对象在堆内存中的存储布局可以分为：**对象头、实例数据、填充数据**

#### 对象头

- 对象头包含两类数据。第一类是存储对象自身的运行时数据，如下图所示
  - ![image-20220719002816544](..\..\image\20220719002751.jpg)
- 另一类是类型指针，JVM通过这个类型指针判断这个对象是哪个类的实例。
- 如果对象是一个数组，那么对象头中海有一块用于记录数组长度的数据。

#### 实例数据

- 就是类中定义的各种类型的字段内容

#### 填充数据

- 就是对齐数据，起占位符的作用。

### 对象的访问定位

- Java程序通过栈帧中的对象引用来操作堆上的具体对象。而访问对象的方式有两种
  - 句柄访问
    - ![image-20220719002726450](..\..\image\image-20220719002726450.png)
  - 直接指针访问
    - ![image-20220719002739484](D:\面试\StudyDoc\image\image-20220719002739484.png)
- **这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而 reference本身不需要被修改。**



## 类加载机制


### 类加载生命周期

![image-20220713150903067](..\..\image\image-20220713150903067.png)

- 加载验证准备初始化和卸载这五个阶段的顺序是确定的，类加载的顺序必须是按照这个顺序开始，**但是这些阶段都会交叉的进行**。
- 解析阶段开始的顺序是不一定的：某些情况下可以在初始化之后才开始。
- 至于什么时候开始加载，JVM规范中没有强制约束。但是初始化的阶段，则是由**六种**情况必须开始，除这六种情况之外，**所有引用类型的方式都不会触发初始化**，也就是被动引用。被动引用参考《JVM》P360.
  1. 遇到new,getstatic,putstatic,invokestatic
  2. 进行反射调用时
  3. 初始化类的时候发现父类没有初始化，需要先初始化父类
  4. 当虚拟机启动的时候，虚拟机会先初始化包含main方法的类
  5. 当一个接口种定义了jdk8新加入的默认方法，也就是default方法，如果有这个接口的实现类发生了初始化，则要优先初始化这个接口
  6. 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解 析结果为REF_getStatic、REF_p utStatic、REF_invokeStatic、REF_newInvokeSp ecial四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
- **而对于接口，接口在初始化的时候，不需要优先初始化父类，只有真正用到父接口的时候，才进行初始化**

### 类加载过程

#### 加载

- 在加载阶段，要完成一下三件事
  1. 通过一个类的全限定名来获取定义此类的二进制字节流
  2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  3. 在内存中生成一个代表这个类的class对象，作为方法区这个类的各种数据的访问入口

#### 验证

1. 文件格式验证
2. 元数据验证
   - 这是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求
   - 比如
     - 是否有父类
     - 父类是否继承了不被允许继承的类
     - 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
     - 等等
3. 字节码验证
4. 符号引用验证

#### 准备

- 准备节点是正式为类中定义的变量分配内存并设置类变量初始值的阶段，这个时候分配的仅是类变量，而不包括实例变量

  ````java
  
      //实例变量
      String id;
      //实例变量
      private String colorType;
      //实例变量
      private int size;
      //类变量(静态变量)
      private static int depart = 1;
  	private static final int value = 100;
  ````

- 不过对于类变量`depart`来讲，这个阶段它的值是0，而不是1。**但是对于`value`来讲，它的初始值是100**，这是因为：**如果类变量存在final，那么在准备阶段变量值就会初始化该变量所指定的初始值。**

#### 解析

- 解析阶段是JVM将常量池内的符号引用替换为直接引用的过程。
- 详情见P371

#### 初始化

- 初始化时类加载过程的最后一个阶段，直到初始化阶段，JVM才开始真正执行类中编写的Java程序代码。**这个时期并非是执行构造方法。执行构造方法是在对象的创建过程。**
- 详情见P376

### 类加载器

- 对于任意一个类，都必须有它的加载器和这个类本身一起确定其在Java中的唯一性。也就是说：**比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。**否则，即使两个类来自同一个class文件，但是由不同的类加载器加载，那么还是不同的类。

#### 双亲委派模型

- 启动类加载器（Bootstrap Class Loader）
  - 这个加载器负责加载存放在<JAVA_HOME>\lib目录下，或者被-Xbootclasspath参数所指定的路径中存放的类，而且是能够被JVM识别的（JVM是按照文件名识别的，否则即使是不符合的类库放到lib下也不会被加载），并且这个加载器是c++代码实现的。

- 扩展类加载器（Extension Class Loader）
  - 这个类加载器是以Java代码实现的，负责加载<JAVA_HOME>\lib\ext目录中的Java代码。
- 应用程序类加载器（Application Class Loader）
  - 以Java实现，用来加载用户类路径也就是ClassPath上的类库，开发者可以在代码中直接使用这个类加载器。如果开发者自己没有定义类加载器，一般这个就是默认的类加载器

<img src="..\..\image\image-20220714180948324.png" alt="image-20220714180948324" style="zoom: 50%;" />

- 上图中所展示的就是**双亲委派模型**，双亲委派模型的工作过程是：**如果一个类加载器收到了类加载的请求，首先它不会自己去加载，而是委派给父加载器去加载，每一个层次的类加载器都是如此，直到加载请求到了启动类加载器，只有当父加载器无法加载，就会让子加载器去加载**
- 使用双亲委派模型来组织类加载器之间的关系，**一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在tr.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。**反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。如果读者有兴趣的话，可以尝试去写一个与rt.jar类库中已有类重名的Java类，将会发现它可以正常编译，但永远无法被加载运行,**即使自定义了自己的类加载器，强行用defineClass()方法去加载一个以“java.lang”开头的类也不会成功。如果读者尝试这样做的话，将会收到一个由JVM内部抛出的“java.lang..SecurityException:Prohibitedpackagename:java.lang”异常。**
- [如果自己写了一个Object会怎么样](如果自己写了一个Object会怎么样)

### 热部署原理

- Tomcat做到热部署就是先检测代码是否有改动，一旦发现改动就会重新定义一个新的类加载器。

## 四种引用 

### 强、软、弱、虚

- 正常我们创建的对象都是强引用对象，只有在这个对象为空的时候，JVM才会进行回收
- 如果创建了一个软引用对象，那么，只有在系统内存不够用的时候，JVM才会进行回收
- 如果创建了一个弱引用，那么，当JVM进行回收的时候，就会进行回收，无论这个引用是否有指针指向。
  - ThreadLocal应用了弱引用
- 虚引用：
  -  `PhantomReference<M> phantomReference = new PhantomReference<>(new M(), QUEUE);`
  -  当 `phantomReference `被回收的时候（也就是`new M()`这个对象为空的时候），这个引用`phantomReference `会被放到`QUEUE`中，虚引用主要是为了NIO的堆外内存回收，因为堆外内存是在操作系统中，不被JVM管理，那么，把一些对象放在这个 弱引用中，`new PhantomReference<>(对象, QUEUE)`，当我们把一些对象指向堆外内存的时候，我们可以去检测`QUEUE`，如果队列中有弱引用存在，我们去查看这个弱引用指向的是哪个对象，然后去堆外内存中回收这个空间。

## 垃圾回收

### JVM垃圾收集GC算法

[JVM垃圾收集GC算法](JVM垃圾收集GC算法.md)

### JVM实战-垃圾收集器

[垃圾收集器](JVM实战-垃圾收集器.md)

[GC分类](复习：GC分类.md)





