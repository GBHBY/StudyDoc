#  Linux

## 定时任务

- ## Crontab

## Java配置环境变量

- 

![image-20210510222607808](D:\面试\面试学习笔记\image-20210510222607808.png)

## 搜索文件

- 如果知道文件在哪个文件夹下： `find /文件位置 -name 文件名`
- 如果不知道文件在哪个文件夹下: `find -name 文件名`
- 如果只是知道大概的文件名：`find -name xx*`

##  赋予权限

- ![image-20210510231159136](D:\面试\面试学习笔记\image-20210510231159136.png)

# Mysql

## 升序降序

- desc降序
- asc升序

## 复制表

- 复制表结构
  - `creat table newTable like major`,创建一个名为newTable的新表，并且表的结构和major的结构一样，也就是字段一样
- 复制表结构和数据
  - `craet table newTable select * from major` ,创建一个名为newTable的新表，并且表的结构和major的结构一样，数据也都复制了
- 复制某个表的某几个字段，但是不复制数据
  - `creat table newTable select 字段1,字段2,字段3,from major where 1=2;`

## 删除表

- delete from tableName wher '条件'
- truncate table tableName
- **truncate**和**delete**区别
  -  **truncate**不可以添加条件，一次性清空所有数据，但不删除表结构，也就说，相当于，把整张表删掉，然后新建了一个空表
  -  **delete**是逐行删掉
  -  truncate效率较高
  -  如果字段带有自动增长
     - 使用delete删除数据，重新插入数据，自动增长的字段会从断点处开始
     - 如果使用truncate，重新插入从1开始

## having

- having是对分组后的每个组进行筛选

## 索引

### explain

- 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

- ![image-20210511184714645](D:\面试\面试学习笔记\image-20210511184714645.png)
- id：id相同，执行顺序从上至下，id不同，id越大，优先级越高，id每个号码，都表示一个独立的查询，id数字越少越好。
- select_type:
  - ![image-20210511184913342](D:\面试\面试学习笔记\image-20210511184913342.png)
- type:
  - ![image-20210511185117199](D:\面试\面试学习笔记\image-20210511185117199.png)
  - 至少要达到range级别，最好是ref
- key_len:越少越好
  - key_len决定了索引项在存储空间占用的大小，越小意味着一个磁盘扇区能够放置的索引项越多（除了叶），从而可以降低B+树的高度，高度低就意味着查找时所搜索的路径越少，比如一个三层B+树，从根到叶节点只需2步，而四层就需要3步了，而搜索的路径少就意味着磁盘IO读取次数少（如果没有全放内存的话），自然就提高查询的效率了。
  - ![image-20210511191710830](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20210511191710830.png)
  - 第一组
    key_len=age的字节长度+name的字节长度=4+1  + ( 20*3+2)=5+62=67
- rows：rows列显示MySQL认为它执行查询时必须检查的行数。越少越好

## 关联

- 通过 explain 查看，从上至下，第一个表是驱动表，驱动表走全表，被驱动走索引

## 排序

- order by
  - 没有过滤条件的话，索引是不会起作用的，如果没有过滤条件,加个分页 `limit x` ,这也是过滤条件，效果会好很多
  - 索引顺序和where字段顺序一致，否则会触发文件排序
  - 如果两个字段，在同一个语句里，一个升序一个降序，一定会导致索引失效，只能是
- group by
  - 没有过滤条件，也能使用索引
  - 索引顺序和where字段顺序一致，否则会触发文件排序
  - 如果两个字段，在同一个语句里，一个升序一个降序，一定会导致索引失效，只能是

## 锁机制

- 共享锁
  - 在读取数据的时候，保证数据不会更改 `lock in share mode`，其他事务不能获取该数据的排他锁

- 排他锁
  - 在修改数据的时候，确保不会同时对统一资源进行操作 `for update`,其他事务不能进行修改该数据，也不能对该资源进行加锁
- innoDB的行锁是通过索引上的索引项加锁实现的，如果加了锁，但是该数据行没有索引，会触发表锁，其他事务在加锁的时候是会出现等待的
- 由于mysql的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现冲突的。



