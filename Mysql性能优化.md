# Mysql性能优化

- 主要针对InnoDB，本文主要是依赖于《高性能MySQL》

## 字段选择

- 在建表的时候，如果业务没有特别要求，每个字段要避免为空，为空的列需要占用更多的存储空间，MySQL也需要进行特殊处理，当可以为空的列作为索引的时候，每个`索引记录`需要一个额外的存储空间，在MyISAM中甚至会导致固定长度的索引变为可变长的索引，这是非常危险的，并且为空，会导致索引失效，如果字段可以为空，那么在查询的时候就会想用`!=`或者`is not null` ，这会导致索引失效（亲测）。但是，并不意味着，将表的字段改为不为空就会提升性能，这对性能的提升不是很大， 要想提升性能，还是要依赖建立优质的索引等方法，只有在不得已的情况下，才进行将 `NULL`改为`NOT NULL`，并且对于大表，改变表的定义，这是非常耗时的（后面会讲到）。当然，对于InnoDB，该引擎使用单独的bit来存储NULL值，这对稀疏矩阵有很高的空间效率，但不适用于MyISAM（这来自于《高性能MySQL》，本人不是很明白，希望有懂的人解释一下）

### 字符串类型

- 对于字符串类型，MySQL有`varchar` `char`等类型，在开发中，首选`varchar`，`varchar`用来储存不定长的字符串，而`char`是定长的字符串，也就是说`varchar`只会占用必要的存储空间，但是`char`，无论是多长的字符串，都是一样的存储空间，这会造成空间浪费。
- `varchar`需要额外的1或者2个字节来记录字符串的长度：
  - 如果列的最大长度小于或者等于255，那么就只需要1个额外字节，否则使用2个字节，比如：在latin1字符集中，`varchar(10)`的列占用11个字节，`varchar(1000)`的列占用1002个字节
- 在5.0以上的版本中，MySQL在存储和检索的时候会保留末尾空格，在低版本中，会剔除掉末尾空格。但是，即使是高版本的MySQL，对于`char`类型，依然会删除掉末尾的空格，但`varchar`不是。
- 由于`char`是存储定长的，那么就适合存储那些长度较为统一，尤其是MD5，对于表中大多数的数据都是很短的情况下，请使用`char`。
- InnoDB中，过长的`varchar`会存储成`BLOB`

### 时间类型

- **千万不要用字符串来存储时间，这是非常愚蠢的行为，只有入门程序员才会这么做**
-  DATATIME
  - 这个类型能存储大范围的时间，从1001到9999年，精确到秒，存储到格式为`YYYYMMDDHHMMSS`的整数中，这个类型的时间与时区是无关的，使用8个字节来存储。
- TIMESTAMP
  - 这个类型时间范围较小，只能到2038年。但是占据的空间较小，只有4个字节。

## 索引

### 聚集索引和非聚集索引

- 聚集索引上的数据是一整行数据，而非聚集索引的数据是响应的聚集索引键。
- 对于InnoDB，当表中的一个主键被定义了，那么这个主键会被定义为聚集索引，如果没有主键被定义，那么InnoDB会取第一个唯一索引而且是非空列作为主键。如果这样的列也没有，那么会自己创建一个隐藏id列，作为聚集索引。

### 关于MySQL的InnoDB的索引结构问题

#### 为什么不使用二叉树、AVL、红黑树

- 如果使用二叉树，如果当数据是等差数列就会呈下图的结构，那么当查找id为8的数据的时候，就要查找8次，效率太低
  - ![image-20220712162204952](image\image-20220712162204952.png)
- 如果使用AVL，也就是平衡二叉树，首先，数据插入的时候会经过很多次的旋转而达到平衡的效果，那么插入的效率就会很低。其次，当数据量很大的时候，AVL的高度会特别高，查询的效率也会很低，所以，不会使用AVL
- 如果使用红黑树。首先，红黑树就是特殊的AVL，红黑树每个节点最多不会超过三次，它不会保证完全平衡，这样插入效率会高一些。**但是**，如果数据量很大，树的深度会很深，只要是使用树作为索引结构，每查询一次数据就会从磁盘中读取一个节点，而每个节点只存储一条数据，由于数据量很大，所以查找数据的时候可能会有多次的磁盘IO，查找效率会很低

#### 为什么不使用B树以及为什么使用B+树

1. 首先，B树中一个节点中会有多个数据，这样呢，整个树结构就会变得‘矮胖’，这样树的高度就会降低，查询效率就会提升，这是和二叉树的区别

2. B+树的所有数据存储在叶子节点，而不是非叶子节点，**非叶子节点只存储索引key**，并且所有的叶子节点由指针链接，如此一来，只需要访问叶子节点就可以完成所有数据的遍历。这两个特点是B树所没有的。如果想要范围查找，那么只需要顺着节点和指针顺序一次就可以遍历范围内的数据。而B树得一个一个去找。

### 强制走索引

- force index（索引名）



### InnoDB

- InnoDB的索引默认会建立主键索引，此时，尽可能让索引是自增的，这样再插入数据的时候不会让存储引擎不停的更改索引树。InnoDB的聚簇索引指的是：数据行和相邻的键值紧紧挨在一起，一个表只能由一个聚簇索引。
- 二级索引的叶子节点是主键值，所以，可以选择建立二级索引从而不会回表而是去主键索引的叶子节点获取数据行。也就是建立覆盖索引，当使用覆盖索引的时候，explan的**Extra**会显示`Using index`

### MylSAM

- 首先，mylsam是根据插入顺序保存在磁盘上
- MylSam是根据行号来创建索引



<img src=".\image\20210927230220.png" alt="QQ图片20210927230220" style="zoom: 33%;" />

## 分库分表

- 使用concat可以使两个结果列合并为一列。

## SQL优化小技巧

### 超长in查询优化

- 问题：有1w名员工id，去查询他们所有人的好友数量

- 主体思路

  1. 创建临时表

     1. `create temporrary table tmp (di_emloyee bigint)`

  2.  将这一万名员工的id放入临时表

     1. `````sql
        insert into tmp (`id_employee`) values 
        	<foreach collection="list" item = "item" separator=",">
        	 #{item}
        	</foreach>
        
        `````

  3. 如果开启了读写分离，需要将此次的查询改为主库查询，如果使用的是shardingsphere 就是：HintManage.getInstance().setmasterroutonly();

  4. 接着就是联表查询，关联这张临时表，速度会提升的很快

### 优化去重

- 不要使用distinct，而是group by相关字段

### 可以将一些子查询改为临时表

- 使用临时表比子查询快很多

### 使用partition

- 这可以让数据库知道你想要的数据就在某一个硬盘中，而不是在全量数据中filter

### 不到最后一步不要order by

### 不适用not in 代替使用 in



### 



































